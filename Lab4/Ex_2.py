def gcdex(a, b):
    # Ініціалізація значень для розширеного алгоритму Евкліда
    x0, x1, y0, y1 = 1, 0, 0, 1 
    while b != 0:
        # Обчислюємо частку та залишок
        q, a, b = a // b, b, a % b
        # Оновлюємо коефіцієнти x та y
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    # Повертаємо НСД та коефіцієнти x0 і y0
    return a, x0, y0

def inverse_element(a, n):
    # Використовуємо розширений алгоритм Евкліда
    gcd, x, _ = gcdex(a, n)
    # Перевіряємо, чи НСД дорівнює 1, що означає, що a та n є взаємно простими
    if gcd == 1:
        # Обернений елемент у модульній арифметиці
        return x % n
    else:
        # Якщо НСД не 1, то оберненого елемента не існує
        return None

# Тестування функції на прикладі a = 5 і n = 18
a = 5
n = 18
inverse = inverse_element(a, n)

if inverse is not None:
    print(f"Мультиплікативний обернений елемент для {a} модуль {n}: {inverse}")
else:
    print(f"Мультиплікативного оберненого елемента для {a} модуль {n} не існує.")
